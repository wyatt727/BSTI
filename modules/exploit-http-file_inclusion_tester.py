#!/usr/bin/env python3
# STARTFILES
# targets.txt "List of potential vulnerable URLs with parameters, one per line (e.g., http://example.com/page.php?file=test)"
# lfi_payloads.txt "File containing LFI payloads to test"
# rfi_test_file.txt "Remote file to host and test for RFI (contains unique marker)"
# ENDFILES
# ARGS
# SCAN_TYPE "Type of scan: all, lfi, rfi (default: all)"
# TIMEOUT "Request timeout in seconds (default: 5)"
# ENDARGS
# AUTHOR: Security Tester

import os
import sys
import urllib.parse
import requests
import concurrent.futures
import time
import random
from datetime import datetime

# Disable SSL warnings
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Constants
MAX_WORKERS = 10
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15",
    "Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0"
]

def get_random_user_agent():
    """Return a random user agent from the list."""
    return random.choice(USER_AGENTS)

def read_file_lines(filepath):
    """Read a file and return its lines as a list."""
    try:
        with open(filepath, 'r') as f:
            return [line.strip() for line in f if line.strip()]
    except Exception as e:
        print(f"Error reading file {filepath}: {str(e)}")
        return []

def test_lfi(url, payloads, timeout):
    """Test for Local File Inclusion vulnerabilities."""
    results = []
    
    # Extract the parameter to test
    parsed_url = urllib.parse.urlparse(url)
    query_params = urllib.parse.parse_qs(parsed_url.query)
    
    if not query_params:
        return [(url, "No parameters found to test LFI.")]
    
    # Common strings found in /etc/passwd
    passwd_markers = ["root:x:0:0", "daemon:", "bin:", "nobody:", "sync:"]
    
    for param in query_params:
        # Test each payload with the parameter
        for payload in payloads:
            test_url = replace_param_value(url, param, payload)
            
            try:
                headers = {'User-Agent': get_random_user_agent()}
                response = requests.get(test_url, headers=headers, timeout=timeout, verify=False)
                
                # Check for signs of successful LFI
                found_markers = [marker for marker in passwd_markers if marker in response.text]
                
                if found_markers:
                    # Confirmed LFI vulnerability
                    result = (test_url, f"VULNERABLE: LFI confirmed! Found {len(found_markers)} markers from /etc/passwd")
                    results.append(result)
                    break  # No need to test more payloads on this parameter
                
                # Check for specific error messages that might indicate partial success
                error_patterns = ["failed to open stream", "include(", "cannot access", "no such file"]
                found_errors = [error for error in error_patterns if error.lower() in response.text.lower()]
                
                if found_errors:
                    result = (test_url, f"POTENTIAL: Found error patterns: {', '.join(found_errors)}")
                    results.append(result)
            
            except requests.RequestException as e:
                results.append((test_url, f"ERROR: {str(e)}"))
    
    return results

def test_rfi(url, timeout):
    """Test for Remote File Inclusion vulnerabilities."""
    results = []
    
    # Extract the parameter to test
    parsed_url = urllib.parse.urlparse(url)
    query_params = urllib.parse.parse_qs(parsed_url.query)
    
    if not query_params:
        return [(url, "No parameters found to test RFI.")]
    
    # Read the unique marker from the RFI test file
    try:
        with open('/tmp/rfi_test_file.txt', 'r') as f:
            marker = f.read().strip()
    except Exception as e:
        return [(url, f"ERROR: Could not read RFI test file: {str(e)}")]
    
    # Common remote file inclusion payloads
    remote_urls = [
        "http://example.com/rfi_test_file.txt",  # Replace with actual server if available
        "http://localhost/rfi_test_file.txt",
        "http://127.0.0.1/rfi_test_file.txt",
        "https://raw.githubusercontent.com/user/repo/master/rfi_test_file.txt"  # Replace with actual GitHub URL if available
    ]
    
    for param in query_params:
        for remote_url in remote_urls:
            test_url = replace_param_value(url, param, remote_url)
            
            try:
                headers = {'User-Agent': get_random_user_agent()}
                response = requests.get(test_url, headers=headers, timeout=timeout, verify=False)
                
                # Check if the marker from the RFI file is in the response
                if marker in response.text:
                    result = (test_url, "VULNERABLE: RFI confirmed! Found unique marker in response")
                    results.append(result)
                    break  # No need to test more remote URLs on this parameter
                
                # Check for specific error patterns
                error_patterns = ["failed to open stream", "include(", "cannot access"]
                found_errors = [error for error in error_patterns if error.lower() in response.text.lower()]
                
                if found_errors:
                    result = (test_url, f"POTENTIAL: Found error patterns: {', '.join(found_errors)}")
                    results.append(result)
            
            except requests.RequestException as e:
                results.append((test_url, f"ERROR: {str(e)}"))
    
    return results

def replace_param_value(url, param, new_value):
    """Replace the value of a specific parameter in a URL."""
    parsed_url = urllib.parse.urlparse(url)
    query_params = urllib.parse.parse_qs(parsed_url.query)
    
    # Update the parameter with the new value
    query_params[param] = [new_value]
    
    # Build the new query string
    new_query = urllib.parse.urlencode(query_params, doseq=True)
    
    # Build and return the updated URL
    return urllib.parse.urlunparse((
        parsed_url.scheme,
        parsed_url.netloc,
        parsed_url.path,
        parsed_url.params,
        new_query,
        parsed_url.fragment
    ))

def main():
    if len(sys.argv) < 2:
        scan_type = "all"
    else:
        scan_type = sys.argv[1].lower()
    
    if len(sys.argv) < 3:
        timeout = 5
    else:
        try:
            timeout = int(sys.argv[2])
        except ValueError:
            print("Invalid timeout value. Using default (5 seconds).")
            timeout = 5
    
    # Validate scan type
    if scan_type not in ["all", "lfi", "rfi"]:
        print("Invalid scan type. Must be one of: all, lfi, rfi. Using 'all'.")
        scan_type = "all"
    
    # Read target URLs
    targets = read_file_lines('/tmp/targets.txt')
    if not targets:
        print("Error: No targets found in the targets.txt file.")
        sys.exit(1)
    
    # Print scan information
    print("=" * 60)
    print(f" File Inclusion Vulnerability Scanner")
    print("=" * 60)
    print(f"Starting scan at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Scan type: {scan_type}")
    print(f"Targets: {len(targets)}")
    print(f"Timeout: {timeout} seconds")
    print("=" * 60)
    
    # Perform LFI scan
    if scan_type in ["all", "lfi"]:
        print("\nTesting for Local File Inclusion (LFI) vulnerabilities...")
        
        # Read LFI payloads
        lfi_payloads = read_file_lines('/tmp/lfi_payloads.txt')
        if not lfi_payloads:
            print("Error: No LFI payloads found in the lfi_payloads.txt file.")
            if scan_type == "lfi":
                sys.exit(1)
        else:
            lfi_results = []
            
            # Create a thread pool to test LFI vulnerabilities concurrently
            with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
                future_to_url = {
                    executor.submit(test_lfi, url, lfi_payloads, timeout): url
                    for url in targets
                }
                
                for future in concurrent.futures.as_completed(future_to_url):
                    url = future_to_url[future]
                    try:
                        results = future.result()
                        lfi_results.extend(results)
                    except Exception as e:
                        print(f"Error testing {url}: {str(e)}")
            
            # Print LFI results
            vulnerable_count = len([r for r in lfi_results if "VULNERABLE" in r[1]])
            potential_count = len([r for r in lfi_results if "POTENTIAL" in r[1]])
            error_count = len([r for r in lfi_results if "ERROR" in r[1]])
            
            print(f"\nLFI Results Summary:")
            print(f"- Confirmed vulnerabilities: {vulnerable_count}")
            print(f"- Potential vulnerabilities: {potential_count}")
            print(f"- Errors: {error_count}")
            
            if vulnerable_count > 0:
                print("\nConfirmed LFI vulnerabilities:")
                for url, result in lfi_results:
                    if "VULNERABLE" in result:
                        print(f"- {url}")
                        print(f"  {result}")
                        print()
            
            if potential_count > 0:
                print("\nPotential LFI vulnerabilities (manual verification required):")
                for url, result in lfi_results:
                    if "POTENTIAL" in result:
                        print(f"- {url}")
                        print(f"  {result}")
                        print()
    
    # Perform RFI scan
    if scan_type in ["all", "rfi"]:
        print("\nTesting for Remote File Inclusion (RFI) vulnerabilities...")
        
        # Check if RFI test file exists
        if not os.path.exists('/tmp/rfi_test_file.txt'):
            print("Error: RFI test file not found.")
            if scan_type == "rfi":
                sys.exit(1)
        else:
            rfi_results = []
            
            # Create a thread pool to test RFI vulnerabilities concurrently
            with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
                future_to_url = {
                    executor.submit(test_rfi, url, timeout): url
                    for url in targets
                }
                
                for future in concurrent.futures.as_completed(future_to_url):
                    url = future_to_url[future]
                    try:
                        results = future.result()
                        rfi_results.extend(results)
                    except Exception as e:
                        print(f"Error testing {url}: {str(e)}")
            
            # Print RFI results
            vulnerable_count = len([r for r in rfi_results if "VULNERABLE" in r[1]])
            potential_count = len([r for r in rfi_results if "POTENTIAL" in r[1]])
            error_count = len([r for r in rfi_results if "ERROR" in r[1]])
            
            print(f"\nRFI Results Summary:")
            print(f"- Confirmed vulnerabilities: {vulnerable_count}")
            print(f"- Potential vulnerabilities: {potential_count}")
            print(f"- Errors: {error_count}")
            
            if vulnerable_count > 0:
                print("\nConfirmed RFI vulnerabilities:")
                for url, result in rfi_results:
                    if "VULNERABLE" in result:
                        print(f"- {url}")
                        print(f"  {result}")
                        print()
            
            if potential_count > 0:
                print("\nPotential RFI vulnerabilities (manual verification required):")
                for url, result in rfi_results:
                    if "POTENTIAL" in result:
                        print(f"- {url}")
                        print(f"  {result}")
                        print()
    
    print("\n" + "=" * 60)
    print(f"Scan completed at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)

if __name__ == "__main__":
    main() 